<!DOCTYPE html>
<html>
<head>
    <title>Streaming Completion</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        #container {
            width: 100%;
            max-width: 650px;
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        #prompt {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            font-size: 16px;
            resize: vertical;
        }
        #submit {
            width: 100%;
            padding: 12px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        #submit:disabled {
            background-color: #a0cfff;
            cursor: not-allowed;
        }
        #submit:hover:not(:disabled) {
            background-color: #0056b3;
        }
        #output {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 6px;
            min-height: 150px;
            white-space: pre-wrap;
            background-color: #f8f9fa;
            font-family: "Courier New", Courier, monospace;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>Pollinations (OpenAI API compatible) Streaming Text Completion</h1>
        <textarea id="prompt" rows="5" placeholder="Enter your prompt here..."></textarea>
        <button id="submit">Get Completion</button>
        <div id="output"></div>
    </div>

    <script>
        const submitButton = document.getElementById('submit');
        const promptInput = document.getElementById('prompt');
        const outputDiv = document.getElementById('output');

        submitButton.addEventListener('click', async () => {
            const prompt = promptInput.value;
            if (!prompt) {
                alert("Please enter a prompt.");
                return;
            }

            outputDiv.textContent = '';
            submitButton.disabled = true;

            try {
                const response = await fetch('https://text.pollinations.ai/openai', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `APIKeyNotRequired` // IMPORTANT: Replace with your API key
                    },
                    body: JSON.stringify({
                        model: 'openai',
                        messages: [{ role: 'user', content: prompt }],
                        stream: true
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Error: ${response.statusText} - ${errorData.error.message}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                
                // *** BUFFERING LOGIC STARTS HERE ***
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }

                    // Add the new chunk to the buffer
                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process all complete lines in the buffer
                    let boundary = buffer.lastIndexOf('\n');
                    if (boundary === -1) {
                        // If there's no newline, wait for more data
                        continue;
                    }
                    
                    const processable = buffer.slice(0, boundary);
                    buffer = buffer.slice(boundary + 1); // Keep the incomplete line for the next chunk

                    const lines = processable.split('\n').filter(line => line.trim() !== '');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.substring(6).trim();
                            if (data === '[DONE]') {
                                break;
                            }
                            if (data) {
                                try {
                                    const parsedLine = JSON.parse(data);
                                    const content = parsedLine.choices?.[0]?.delta?.content;
                                    if (content) {
                                        outputDiv.textContent += content;
                                    }
                                } catch (error) {
                                    console.error('Error parsing JSON from stream:', error, "Data:", data);
                                }
                            }
                        }
                    }
                }
                // *** BUFFERING LOGIC ENDS HERE ***

            } catch (error) {
                outputDiv.textContent = error.message;
                console.error("An error occurred:", error);
            } finally {
                submitButton.disabled = false;
            }
        });
    </script>
</body>
</html>