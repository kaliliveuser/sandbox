<!DOCTYPE html>
<html>
<head>
    <title>Floating Blob</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, blob, light, spotLight;
        let time = 0;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.SphereGeometry(1, 512, 512);
            const material = new THREE.MeshStandardMaterial({
                color: 0x0000ff,
                metalness: 0.9,
                roughness: 0.05,
                onBeforeCompile: shader => {
                    shader.uniforms.time = { value: 0 };
                    shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        `
                        vec3 transformed = vec3(position);
                        float freq = 2.0;
                        float amp = 0.15;
                        float noise = sin(freq * position.y + time) * amp;
                        noise += cos(freq * position.x + time) * amp;
                        noise += sin(freq * position.z + time) * amp;
                        transformed += normal * noise;
                        vNormal = normalMatrix * normalize(normal + noise);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
                        `
                    );
                    material.userData.shader = shader;
                }
            });
            blob = new THREE.Mesh(geometry, material);
            scene.add(blob);

            light = new THREE.PointLight(0xffffff, 2, 100);
            light.position.set(0, -5, -3);
            scene.add(light);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x00aaff, 1);
            scene.add(hemisphereLight);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            camera.position.z = 5;

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.005;

            if (blob.material.userData.shader) {
                blob.material.userData.shader.uniforms.time.value = time;
            }

            blob.position.y = Math.sin(time * 0.5) * 2;

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
